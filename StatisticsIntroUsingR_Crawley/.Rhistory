exp <- heads*prob.heads
exp <- sum(heads*prob.heads)
s <- sqrt(sum(heads^2*prob.heads))
s <- sqrt(sum(heads^2*prob.heads)-exp^2)
dbinom(x=2, size=5, prob=0.05)
1-pbinom(2, 5, 0.05)
dbinom(5,5,0.05)
1-pbinom(14, 20, 1/5)
prob=1/5
size=20
1-pbinom(14, 20, 2/15)
1-pbinom(14, 20, 1/15)
1-pbinom(14, 20, 1/5)
1-pbinom(14, 20, 1/2)
dbinom(8, 8, 0.77)
1-pbinom(4, 8, 0.77)
dbinom(3, 8, 0.77)
pbinom(2, 10, 0.103)
1-pbinom(5, 10, 0.103)
1-pbinom(5, 10, (1-0.103))
pbimom(5, 10, 0.103)
pbinom(5, 10, 0.103)
pbinom(5, 10, (1-0.103))
dbinom(10, 10, 0.103)
1-dbinom(10, 10, 0.103)
dbinom(0, 10, 0.103)
pbinom(5,10, 0.103)
pbinom(3, 7, 0.75)
dbinom(0, 5, 0.521)
1-pbinom(2, 5, 0.521)
1-pbinom(3, 5, 0.521)
pbinom(1, 5, 0.521)
dbinom(2, 5, 0.4)
pbinom(3, 5, 0.4)
1-pbinom(1, 5, 0.4)
pbinom(1, 5, 0.6)
pbinom(1, 5, 0.4)
pbinom(2, 5, 0.4)
dbinom(6, 12, 0.26)
1-pbinom(5, 12, 0.26)
pbinom(4, 12, 0.26)
dbinom(5, 10, 0.53)
1-pbinom(4, 10, 0.53)
1-pbinom(4, 10, 0.47)
1-pbinom(4, 10, 0.53)+1-pbinom(4, 10, 0.47)
pbinom(4, 10, 0.53)
dbinom(5, 18, 0.25)
dbinom(9, 14, 0.63)
pbinom(3, 10, 1/3)
dbinom(12, 20, 0.58)
1-pbinom(2, 5, 0.13)
dbinom(2, 7, 0.14) + dbinom(3, 7, 0.14)
curve(dbinom(x, 4, 0.3), xlim=c(-5, 5))
x <- -5:5
plot(x, dbinom(x, 4, 0.3), pch=19, col="deeppink1")
plot(x, dbinom(x, 4, 0.3), pch=19, col="orchid1")
library(shiny)
q()
getwd()
setwd("/datascience/projects/statisticallyfit/github/
learningprogramming/R/StatisticsIntroUsingR_Crawley")
setwd("/datascience/projects/statisticallyfit/github/learningprogramming/R/StatisticsIntroUsingR_Crawley")
getwd()
yvals <- read.csv("data/yvalues.csv")
attach(yvals)
hist(y)
hist(yvals)
yvals
attach(yvals)
detach(yvals)
y
detach(yvals)
y
attach(yvals)
y
hist(y)
hist(y, main="")
library(ISwR)
library(ISwR)
getwd()
setwd("/datascience/projects/statisticallyfit/github/learningprogramming/R/IntroductionToStatisticsWithR_Dalgaard")
library(ISwR)
setwd("/datascience/projects/statisticallyfit/github/learningprogramming/R/IntroductionToStatisticsWithR")
library(ISwR)
setwd("/datascience/projects/statisticallyfit/github/learningprogramming/R/StatisticsIntroUsingR_Crawley")
setwd("/home/statisticallyfit")
library(ISwR)
setwd("/datascience/projects/statisticallyfit/github/learningprogramming/R/StatisticsIntroUsingR_Crawley")
yvals <- read.csv("data/yvalues.csv")
attach(yvals)
detacj(yvals)
detach(yvals)
hist(y)
y
yvals <- read.csv("data/yvalues.csv")
y
hist(y)
y
hist(y)
arithmetic.mean <- function(x) sum(x)/length(x)
arithmetic.mean(y)
sorted <- sort(y)
length(y)
data <- c(1,2,3,4,5)
length(data)/2
sorted[ceiling(length(y)/2)]
sort(y)[ceiling(length(y)/2)]
data <- c(1,2,3,4,5, 6)
length(data)/3
length(data)/2
median <- function(x) {
if(length(x) %%2 == 0)
(sort(x)[ceiling(length(x)/2)] + sort(x)[ceiling(1+length(x)/2)])/2
else
sort(x)[ceiling(length(x)/2)]
}
median(y)
med <- function(x) {
if(length(x) %%2 == 0)
(sort(x)[ceiling(length(x)/2)] + sort(x)[ceiling(1+length(x)/2)])/2
else
sort(x)[ceiling(length(x)/2)]
}
med(y)
y
hist(y)
library(ISwR)
setwd("/home/statisticallyfit")
hist(y)
setwd("/home/statisticallyfit")
hist(y)
q()
n
sumXY = sum(tannin*growth)
sumXsumY = sum(tannin)*sum(growth)
sumX2_individ = sum(tannin^2)
sumX2_all = (sum(tannin))^2
SSXY = (sumXY - sumXsumY/n)
SSX = (sumX2_individ - sumX2_all/n)
n = length(tannin)
b = SSXY/SSX
a = mean(growth) - b*mean(tannin)
reg.data <- read.csv("data/tannin.csv")
attach(reg.data)
reg.data
plot(tannin, growth, pch=19, col="cyan")
lm(growth~tannin)
abline(lm(growth~tannin, col="dodgerblue"))
fitted <- predict(lm(growth~tannin))
fitted
lines(c(0,0), c(12, fitted[1]))
for(i in 1:length(fitted))
lines(c(tannin[i], tannin[i]), c(growth[i], fitted[i]), col="red")
getwd()
setwd("/datascience/projects/statisticallyfit/github/learningprogramming/R/StatisticsIntroUsingR_Crawley")
getwd()
reg.data <- read.csv("data/tannin.csv")
reg.data <- read.csv("data/tannin.csv")
attach(reg.data)
reg.data
plot(tannin, growth, pch=19, col="cyan")
lm(growth~tannin)
abline(lm(growth~tannin, col="dodgerblue"))
fitted <- predict(lm(growth~tannin))
fitted
lines(c(0,0), c(12, fitted[1]))
for(i in 1:length(fitted))
lines(c(tannin[i], tannin[i]), c(growth[i], fitted[i]), col="red")
# Looping through values to extract best estimate of b
b <- seq(-1.43, -1, 0.002)
sse <- numeric(length(b)) # sum of squared residuals
for(i in 1: length(b)){
a <- mean(growth) - b[i]*mean(tannin)
residual <- growth - a - b[i]*tannin
sse[i] <- sum(residual^2)
}
plot(b, sse, type="l", ylim=c(19, 24))
arrows(-1.216, 20.07225, -1.216, 19, col="red")
abline(h=20.07225, col="green", lty=2)
lines(b, sse)
b[which(sse==min(sse))]
# Doing calculation of b by hand
# b = SSXY/SSX
# a = meany - b*meanx
# SSR = SSXY^2/SSX
# r = SSXY/sqrt(SSX*SSY)
sumXY = sum(tannin*growth)
sumXsumY = sum(tannin)*sum(growth)
sumX2_individ = sum(tannin^2)
sumX2_all = (sum(tannin))^2
SSXY = (sumXY - sumXsumY/n)
SSX = (sumX2_individ - sumX2_all/n)
n = length(tannin)
b = SSXY/SSX
a = mean(growth) - b*mean(tannin)
# ANOVA to find standard errors of slope and intercept
# SSY = SSE + SSR
# SSR = b*SSXY
SSY = (sum(growth^2) - (sum(growth))^2/n)
SSR = b*SSXY # explained variation
SSE = SSY - SSR # variation that is unexplained by the LSRL
# df of SSY = n-1 = 8
# df of SSE = n-2 = 7
# df of SSR = 1
varY = SSY/8
varE = SSE/7
varR = SSR/1
# F ratios - is varR significantly greater than varE? (is there much more explained variance than unexplained variance?)
f.ratio <- varR/varE
f.ratio
1-pf(f.ratio, df1=1, df2=7) # yes
# Standard error of slope (b)
# SEb = sqrt(varE/SSX), where varE = SSE/(n-2)
# NOTE: when variance of x values (SSX) increases, the data is more like a line + there is more clarity, so error in slope is reduced
SEb = sqrt(varE/SSX)
SEb
n = length(tannin)
sumXY = sum(tannin*growth)
sumXsumY = sum(tannin)*sum(growth)
sumX2_individ = sum(tannin^2)
sumX2_all = (sum(tannin))^2
SSXY = (sumXY - sumXsumY/n)
SSX = (sumX2_individ - sumX2_all/n)
b = SSXY/SSX
a = mean(growth) - b*mean(tannin)
# ANOVA to find standard errors of slope and intercept
# SSY = SSE + SSR
SSY = (sum(growth^2) - (sum(growth))^2/n)
SSR = b*SSXY # explained variation
SSE = SSY - SSR # variation that is unexplained by the LSRL
# df of SSY = n-1 = 8
# df of SSE = n-2 = 7
# df of SSR = 1
varY = SSY/8
varE = SSE/7
varR = SSR/1
# F ratios - is varR significantly greater than varE? (is there much more explained variance than unexplained variance?)
f.ratio <- varR/varE
f.ratio
1-pf(f.ratio, df1=1, df2=7) # yes
# Standard error of slope (b)
# SEb = sqrt(varE/SSX), where varE = SSE/(n-2)
# NOTE: when variance of x values (SSX) increases, the data is more like a line + there is more clarity, so error in slope is reduced
SEb = sqrt(varE/SSX)
SEb
n
SEa = sqrt(varE * sum(tannin^2)/(n*SSX))
SEa
SEpred = sqrt(varE * (1/n + (tanning - mean(tannin))^2/SSX))
SEpred = sqrt(varE * (1/n + (tannin - mean(tannin))^2/SSX))
SEpred
SEpred = sqrt(varE * (1/n + sum((tannin - mean(tannin))^2)/SSX))
SEpred
SEb
varE
varR
varY
SSY
SSE
SSR
varE
SSE/7
model <- lm(growth~tannin)
model
summary(model)
f.ratio
1-pf(f.ratio, df1=1, df2=7) # yes
summary.aov(model)
SSY = (sum(growth^2) - (sum(growth))^2/n)
SSR = b*SSXY # explained variation
SSE = SSY - SSR # variation that is unexplained by the LSRL
varY = SSY/8
varE = SSE/7
varR = SSR/1
f.ratio <- varR/varE
f.ratio
r = sqrt(SSR/SSY)
r
cor(tannin, growth)
plot(tannin, growth)
par(mfrow=c(2,2))
plot(model)
plot(lm(growth~tannin))
plot(model)
influence.measures(model)
par(mfrow=c(1,1))
par(mfrow=c(1,1))
plot(model) # residualsvs fitted, normal QQ, scale-location, residuals vs leverage
data <- read.csv("data/decay.csv")
decay <- read.csv("data/decay.csv")
attach(deca)
attach(decay
attach(decay)
decay
par(mfrow=c(1,1))
decay <- read.csv("data/decay.csv")
attach(decay)
decay
plot(time, amount, pch=19, col="dodgerblue")
model <- lm(amount~time)
model
cor(time, amoutn)
cor(time, amount)
cor.test(time, amount)
plot(time, amount, pch=19, col="dodgerblue"); abline(model, col="red")
abline(model, col="red")
abline(model, lwd=3, col="red")
abline(model, lwd=3, col="orangered")
abline(model, lwd=3, col="firetruckred")
abline(model, lwd=3, col="firetruck")
abline(model, lwd=3, col="red")
abline(model, lwd=2, col="red")
plot(time, amount, pch=19, col="dodgerblue");
abline(model, lwd=2, col="red")
summary(model)
sumr = summary(model)
sumr$residuals
plot(time, sumr$residuals)
sm = summary(model)
smy = summary(model)
plot(time, smy$residuals, pch=19, col="red")
plot(time, smy$residuals, pch=19, col="green")
smy
plot(time, log(amount), pch=19, col="dodgerblue")
abline(lm(log(amount)~time), col="red")
log.model <- (lm(log(amount)~time)
abline(log.model, col="red")
log.model <- lm(log(amount)~time
abline(log.model, col="red")
log.model <- lm(log(amount)~time)
abline(log.model, col="red")
summary(log.model)
smy
summary = summary(model)
summary
plot(time, summary$residuals, pch=19, col="green")
log.summary <- summary(log.model)
log.summary
log.summary$coefficients
log.summary$coefficients[1]
log.summary$coefficients[2]
log.summary$coefficients[,1] # y intercept
log.summary$coefficients[1,] # y intercept
log.summary$coefficients[1] # y intercept
a = log.summary$coefficients[1] # y intercept
b = log.summary$coefficients[2] # slope
y = a*e^(-b*x)
y = a*exp(-b*x)
y = a*exp(-b*tannin)
y
plot(tannin, y)
a
b
SEa
a.exp.model = log.summary$coefficients[1] # y intercept
b.exp.model = log.summary$coefficients[2] # slope
SEa.exp.model <- log.summary$coefficients[1,][2]
SEa.exp.model
upper <- a.exp.model + SEa.exp.model
lower <- a.exp.model - SEa.exp.model
exp(upper)
exp(lower)
exp(a.exp.model)
plot(log.model)
par(mfrow=c(1,1))
plot(time, amount, pch=19, col="dodgerblue")
x.exp <- seq(0, 30, by=0.25)
a.exp.model = log.summary$coefficients[1] # y intercept
exp(a.exp.model)
y.exp <- exp(a.exp.model)*exp(b.exp.model*x.exp)
lines(x.exp, y.exp, col="red", lwd=2)
par(mfrow=c(2,2))
curve(-x^2/10 + 2*x + 4, col="red", ylab="y")
curve(-(x^2)/10 + 2*x + 4, col="red", ylab="y")
par(mfrow=c(2,2))
curve(-(x^2)/10 + 2*x + 4, col="red", ylab="y")
curve(-x^2/5 + 2*x + 4, col="blue", ylab="y")
curve(-(x^2)/10 + 2*x + 4, 0, 10, col="red", ylab="y")
curve(-(x^2)/10 + 2*x + 4, xlim=c(0,10), col="red", ylab="y")
par(mfrow=c(2,2))
curve(-(x^2)/10 + 2*x + 4, xlim=c(0,10), col="red", ylab="y")
curve(-x^2/5 + 2*x + 4, xlim=c(0,10), col="blue", ylab="y")
curve(3*x^2/10 - 4*x + 12, xlim=c(0, 10), col="green", ylab="y")
curve(x^2/10 + x/2 + 4, xlim=c(0, 10), col="goldenrod1", ylab="y")
par(mfrow=c(1,1))
curve(-(x^2)/10 + 2*x + 4, xlim=c(0,10), col="red", ylab="y")
curve(-x^2/5 + 2*x + 4, xlim=c(0,10), col="blue", ylab="y")
curve(3*x^2/10 - 4*x + 12, xlim=c(0, 10), col="green", ylab="y")
curve(x^2/10 + x/2 + 4, xlim=c(0, 10), col="goldenrod1", ylab="y")
par(mfrow=c(2,2))
curve(-(x^2)/10 + 2*x + 4, xlim=c(0,10), col="red", ylab="y")
curve(-x^2/5 + 2*x + 4, xlim=c(0,10), col="blue", ylab="y")
curve(3*x^2/10 - 4*x + 12, xlim=c(0, 10), col="green", ylab="y")
curve(x^2/10 + x/2 + 4, xlim=c(0, 10), col="goldenrod1", ylab="y")
par(mfrow=c(2,2))
curve(-(x^2)/10 + 2*x + 4, xlim=c(0,10), col="red", ylab="y")
curve(-x^2/5 + 2*x + 4, xlim=c(0,10), col="red", ylab="y")
curve(3*x^2/10 - 4*x + 12, xlim=c(0, 10), col="red", ylab="y")
curve(x^2/10 + x/2 + 4, xlim=c(0, 10), col="red", ylab="y")
linear.model <- lm(amount~time)
quad3.model <- lm(amount~time + |(time^2)) # | means "as is"
quad3.model <- lm(amount~time +|(time^2)) # | means "as is"
quad3.model <- lm(amount ~time+|(time^2)) # | means "as is"
model3 <- lm(amount~time+I(time^2))
quad3.model <- lm(amount ~time + I(time^2)) # I means "as is"
summary(quad3.model)
quad.summary <- summary(quad3.model)
quad.summary$coefficients[1]
b = quad.summary$coefficients[2]
c = quad.summary$coefficients[1]
b
a = quad.summary$coefficients[3]
x.quad <- seq(0, 30, by=0.25)
y.quad <- a*x.quad^2 + b*x.quad + c
par(mfrow=c(1,1))
plot(time, amount, pch=19, col="dodgerblue")
x.quad <- seq(0, 30, by=0.25)
y.quad <- a*x.quad^2 + b*x.quad + c
lines(x.quad, y.quad, col="red", lwd=2)
quad.model <- lm(amount ~ time + I(time^2)) # I means "as is" and in the model formula, ^ means order of interaction terms to be fitted
quad.summary <- summary(quad.model)
AIC(linear.model, quad.model)
anova(linear.model, quad.model)
detach(decay)
deer <- read.csv("data/jaws.csv")
attach(deer)
deer
par(mfrow=c(1,1))
plot(age, bone, pch=19, col="brickred")
plot(age, bone, pch=19, col="plum")
plot(age, bone, pch=21, col="plum")
plot(age, bone, pch=20, col="plum")
list(a=120, b=110, c=0.064)
nonlinear.model <- nls(bone ~ a - b*exp(-c*age),
start=list(a=120, b=110, c=0.064))
nonlinear.model
summary(nonlinear.model)
nonlinear.model2 <- nls(bone ~ a(1-exp(-c*age)), start=list(a=120, c=0.064))
nonlinear.model2 <- nls(bone ~ a*(1-exp(-c*age)), start=list(a=120, c=0.064))
nonlinear.model2
anova(nonlinear.model, nonlinear.model2)
av <- seq(0, 50, by=0.1)
bv <- predict(nonlinear.model2, list=(age=av))
list(age=av)
age
av
list(age=av) == av
bv <- predict(nonlinear.model2, list=(age=av)) # generate predicted bone lengths
lines(av, bv, col="blue")
av <- seq(0, 50, by=0.1)
bv <- predict(nonlinear.model2, list=(age=av)) # generate predicted bone lengths and use list to assign av to age
lines(av, bv, col="blue")
av <- seq(0, 50, by=0.011)
bv <- predict(nonlinear.model2, list=(age=av)) # generate predicted bone lengths and use list to assign av to age
lines(av, bv, col="blue")
summary(nonlinear.model2)
nonlinear.summary <- summary(nonlinear.model2)
a = nonlinear.summary$coefficients[1]
b = nonlinear.summary$coefficients[2]
x.nonlin <- av
c = nonlinear.summary$coefficients[2]
y.nonlin <- a(1-exp(-c*x.nonlin))
lines(x.nonlin, y.nonlin, col="blue")
y.nonlin <- a(1-exp(-c*x.nonlin))
y.nonlin <- a*(1-exp(-c*x.nonlin))
lines(x.nonlin, y.nonlin, col="blue")
lines(x.nonlin, y.nonlin, col="blue", lwd=2)
nonlinear.summary
null.model <- lm(bone ~ 1)
summary.aov(null.model)
summary(null.model)
summary.aov(null.model)
SSY = summary.aov(null.model)[2]
SSY
summary.aov(null.model)[2]
summary.aov(null.model)[1]
summary.aov(null.model)[1,]
summary.aov(null.model)[,1]
summary.aov(null.model)[[1]]
typeof(summary.aov(null.model))
list(a=140, b=120, c=3)
l = list(a=140, b=120, c=3)
l
l[1]
l[3]
SSY = summary.aov(null.model)
SSY[1]
SSY = 59008
SSE = 13.1^2*52
Rsquared <-(SSY-SSE)/SSY # or over SST because SST = SSY
Rsquared
Rsquared <- 100*(SSY-SSE)/SSY # or over SST because SST = SSY
Rsquared
detach(deer)
library(mgcv)
hump <- read.csv("data/hump.csv")
library(nlme)
hump <- read.csv("data/hump.csv")
attach(hump)
hump
y
help(library)
detach(package:mgcv)
detach(package:nlme)
y
hump <- read.csv("data/hump.csv")
detach(hump)
detach(hump)
detach(hump)
attach(hump)
q()
q()
